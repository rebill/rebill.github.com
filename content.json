[{"title":"使用信号量实现 goroutine 并发控制","date":"2019-04-08T06:41:54.000Z","path":"2019/04/08/use-semaphores-to-implement-goroutine-concurrency-control/","text":"示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"context\" \"fmt\" \"sync\" \"time\" \"golang.org/x/sync/semaphore\")func doSomething(u string) &#123; fmt.Println(u) time.Sleep(2 * time.Second)&#125;const ( Limit = 3 // 最大并发执行次数 Weight = 1)func main() &#123; urls := []string&#123; \"http://www.example.com\", \"http://www.example.net\", \"http://www.example.net/foo\", \"http://www.example.net/bar\", \"http://www.example.net/baz\", &#125; s := semaphore.NewWeighted(Limit) var w sync.WaitGroup for _, u := range urls &#123; w.Add(1) s.Acquire(context.Background(), Weight) go func(u string) &#123; doSomething(u) s.Release(Weight) w.Done() &#125;(u) &#125; w.Wait()&#125;","tags":[{"name":"Semaphore","slug":"Semaphore","permalink":"https://rebill.github.io/tags/Semaphore/"},{"name":"goroutine","slug":"goroutine","permalink":"https://rebill.github.io/tags/goroutine/"},{"name":"concurrency control","slug":"concurrency-control","permalink":"https://rebill.github.io/tags/concurrency-control/"}]},{"title":"Java大师之路（扩展篇）","date":"2019-01-16T03:24:59.000Z","path":"2019/01/16/the-road-to-java-master-extend/","text":"Java大师之路（扩展篇） Java大师之路（基础篇） Java大师之路（进阶篇） Java大师之路（高级篇） Java大师之路（架构篇） Java大师之路（扩展篇）","tags":[]},{"title":"Java大师之路（架构篇）","date":"2019-01-16T03:24:12.000Z","path":"2019/01/16/the-road-to-java-master-architecture/","text":"Java大师之路（架构篇） Java大师之路（基础篇） Java大师之路（进阶篇） Java大师之路（高级篇） Java大师之路（架构篇） Java大师之路（扩展篇）","tags":[]},{"title":"Java大师之路（高级篇）","date":"2019-01-16T03:23:58.000Z","path":"2019/01/16/the-road-to-java-master-senior/","text":"Java大师之路（高级篇） Java大师之路（基础篇） Java大师之路（进阶篇） Java大师之路（高级篇） Java大师之路（架构篇） Java大师之路（扩展篇）","tags":[]},{"title":"Java大师之路（进阶篇）","date":"2019-01-16T03:20:54.000Z","path":"2019/01/16/the-road-to-java-master-advanced/","text":"Java大师之路（进阶篇） Java大师之路（基础篇） Java大师之路（进阶篇） Java大师之路（高级篇） Java大师之路（架构篇） Java大师之路（扩展篇）","tags":[]},{"title":"Java大师之路（基础篇）","date":"2019-01-16T03:20:11.000Z","path":"2019/01/16/the-road-to-java-master-base/","text":"Java大师之路（基础篇） Java大师之路（基础篇） Java大师之路（进阶篇） Java大师之路（高级篇） Java大师之路（架构篇） Java大师之路（扩展篇）","tags":[]},{"title":"Java大师之路","date":"2019-01-16T02:56:06.000Z","path":"2019/01/16/the-road-to-java-master/","text":"Java大师之路 Java大师之路（基础篇） Java大师之路（进阶篇） Java大师之路（高级篇） Java大师之路（架构篇） Java大师之路（扩展篇）","tags":[]},{"title":"Java 8 Optional 详解","date":"2018-12-26T09:03:26.000Z","path":"2018/12/26/java-8-optional/","text":"概述工作中经常会有这样的一个经历： 调用一个方法获得的返回值可能为空，需要进行null判断，然后再做一些相应的业务处理，或者直接抛出NullPointerException。 为了减少这样的null值判断，java官方借鉴Google Guava类库的Optional类，在java8 中引入了一个同样名字的Optional类，官方javadoc描述如下： IconA container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value. Optional是 java.util 的一个子类，通过以下方式引入1import java.util.Optional; Optional类简介of为非Null值创建一个Optional of方法通过工厂方法创建Optional实例，需要注意的是传入的参数不能为null，否则抛出NullPointerException。 1234// 给与一个非空值Optional&lt;String&gt; username = Optional.of(\"Unknown\");// 传入参数为null，抛出NullPointerException.Optional&lt;String&gt; nullValue = Optional.of(null); ofNullable为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。 可为空的Optional 123// 下面创建了一个不包含任何值的Optional实例// 输出Optional.emptyOptional empty = Optional.ofNullable(null); isPresent如果值存在返回true,否则返回false类似下面的代码:12345// isPresent方法用来检查Optional实例中是否包含值if (username.isPresent()) &#123; //在Optional实例内调用get()返回已存在的值 System.out.println(username.get()); //输出：Unknown&#125; get如果Optional有值则将其返回，否则抛出NoSuchElementException。 1234567// 执行下面的代码抛出NoSuchElementExceptiontry &#123; // 在空的Optional实例上调用get() System.out.println(empty.get()); &#125; catch (NoSuchElementException ex) &#123; System.out.println(ex.getMessage()); // 输出：No value present&#125; 小试牛刀看语法介绍都是很枯燥的，我们来一个生动的例子。 先来看看在没有Optional之前我们的代码是怎么写的。 12345public static String getName(User u) &#123; if (u == null) return \"Unknown\"; return u.name;&#125; 有了Optional之后，你可能会把代码改成下面这样： 123456public static String getName(User u) &#123; Optional&lt;User&gt; user = Optional.ofNullable(u); if (!user.isPresent()) return \"Unknown\"; return user.get().name;&#125; 看上去仍然是在原地踏步，实质上是没有任何分别。 更优雅OptionalLet me Show you the code: 12345public static String getName(User u) &#123; return Optional.ofNullable(u) .map(user-&gt;user.name) .orElse(\"Unknown\");&#125; 更复杂的例子123456789101112public static String getChampionName(Competition comp) throws IllegalArgumentException &#123; if (comp != null) &#123; CompResult result = comp.getResult(); if (result != null) &#123; User champion = result.getChampion(); if (champion != null) &#123; return champion.getName(); &#125; &#125; &#125; throw new IllegalArgumentException(\"The value of param comp isn't available.\");&#125; 由于种种原因（比如：比赛还没有产生冠军、方法的非正常调用、某个方法的实现里埋藏的大礼包等等），我们并不能开心的一路comp.getResult().getChampion().getName()到底。 让我们看看经过Optional加持过后，这些代码会变成什么样子。 1234567public static String getChampionName(Competition comp) throws IllegalArgumentException &#123; return Optional.ofNullable(comp) .map(c-&gt;c.getResult()) .map(r-&gt;r.getChampion()) .map(u-&gt;u.getName()) .orElseThrow(()-&gt;new IllegalArgumentException(\"The value of param comp isn't available.\"));&#125; Optional给了我们一个真正优雅的Java风格的方法来解决null安全问题。 更多神奇魅力为空则不打印可以这么写： 1string.ifPresent(System.out::println); 检验参数的合法性 1234public void setName(String name) throws IllegalArgumentException &#123; this.name = Optional.ofNullable(name).filter(User::isNameValid) .orElseThrow(()-&gt;new IllegalArgumentException(\"Invalid username.\"));&#125; Optional类深入学习orElse如果有值则将其返回，否则返回指定的其它值。如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下： 123456@Testpublic void whenOrElseWorks_thenCorrect() &#123; String nullName = null; String name = Optional.ofNullable(nullName).orElse(\"Unknown\"); assertEquals(\"Unknown\", name);&#125; orElseGetorElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下： 123456@Testpublic void whenOrElseGetWorks_thenCorrect() &#123; String nullName = null; String name = Optional.ofNullable(nullName).orElseGet(() -&gt; \"Unknown\"); assertEquals(\"Unknown\", name);&#125; map如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。 map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。map方法示例如下： 1234567891011@Testpublic void givenOptional_whenMapWorks_thenCorrect() &#123; List&lt;String&gt; companyNames = Arrays.asList( \"paypal\", \"oracle\", \"\", \"microsoft\", \"\", \"apple\"); Optional&lt;List&lt;String&gt;&gt; listOptional = Optional.of(companyNames); int size = listOptional .map(List::size) .orElse(0); assertEquals(6, size);&#125; 更多方法 ifPresent 如果Optional实例有值则为其调用consumer ,否则不做处理。 orElseThrow 如果有值则将其返回，否则抛出supplier接口创建的异常。 flatMap 如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。 filter filter个方法通过传入限定条件对Optional实例的值进行过滤。如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。 不再一一介绍。 JDK 9 又新增了几个API the or() method for providing a supplier that creates an alternative Optional the ifPresentOrElse() method that allows executing an action if the Optional is present or another action if not stream() method for converting an Optional to a Stream 总结使用 Optional 时尽量不直接调用 Optional.get() 方法，Optional.isPresent() 更应该被视为一个私有方法，应依赖于其他像 Optional.orElse()、Optional.orElseGet()、Optional.map() 等这样的方法。 最好的理解 Java 8 Optional 的方法莫过于看它的源代码 java.util.Optional，阅读了源代码才能真真正正的让你解释起来最有底气，Optional 的方法中基本都是内部调用 isPresent() 判断，真时处理值, 假时什么也不做。 参考资料 Java8 Optional 详解 Java8 如何正确使用 Optional Guide To Java 8 Optional 使用 Java8 Optional 的正确姿势","tags":[{"name":"Java","slug":"Java","permalink":"https://rebill.github.io/tags/Java/"},{"name":"Optional","slug":"Optional","permalink":"https://rebill.github.io/tags/Optional/"}]}]